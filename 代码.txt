#!/usr/bin/env python
# coding: utf-8

# In[94]:



# # 导入库

# In[95]:
import os

import numpy as np
import pandas as pd
from numpy import sin,cos
from skspatial.objects import Line, Cylinder
from skspatial.plotting import plot_3d
import matplotlib.pyplot as plt
import time
import plotly.express as px

from pymoo.algorithms.moo.nsga2 import NSGA2
from pymoo.operators.crossover.sbx import SBX
from pymoo.operators.mutation.pm import PM
from pymoo.operators.sampling.rnd import FloatRandomSampling
from pymoo.termination import get_termination
from pymoo.optimize import minimize

# # 变量定义

# In[96]:


'''定义变量'''
# LED parameters
theta = 70  # semi-angle at half power
m = -np.log10(2) / np.log10(np.cos(np.radians(theta)))  # Lambertian order of emission
P_total = 10  # transmitted optical power by individual LED,光功率
Adet = 1e-4  # detector physical area of a PD
rho_wall = 0.8  # reflection coefficient
rho_irs = 0.95  # reflection coefficient
h=0.75 # 接收高度
B=200*1e+6 # 200 Mhz → 200*1e+6 Hz 
N=1e-21 # A^2/Hz
R_pd=0.53 #A/W 2.17改

# Optics parameters
p=P_total # 光功率
Pt=P_total #总光功率？四盏灯 原本*4
q= 3
Ts = 1  # Gain of an optical filter; ignore if no filter is used
index = 1.5  # refractive index of a lens at a PD; ignore if no lens is used（文献f）
FOV = 85  # FOV of a receiver
FOV_radian=np.radians(FOV) # FOV的弧度

G_Con = (index**2) / (np.sin(np.radians(FOV))**2)  # Gain of an optical concentrator

# Room parameters
lx = 5 # 房间的规格
ly = 5
lz = 3  # room dimension in meter

Nx = 20  # 地面X方向的网格数
Ny = 20  # 地面Y方向的网格数
Nz = 20  # 墙面Z方向的网格数

# Cylinder parameters: 圆柱体的参数
cylinder_x=2.5 # 圆柱体底面圆心的X坐标
cylinder_y=2.5 # 圆柱体底面圆心的Y坐标
cylinder_h=1.65 # 圆柱体的高度
cylinder_r=0.15 # 圆柱体的半径

'''导出变量'''
stepX=lx/Nx # 地面X方向的网格间距
stepY=ly/Ny # 地面Y方向的网格间距
stepZ=lz/Nz # 墙面Z方向的网格间距
dA = stepY*stepZ # 墙面网格的面积

'''镜子变量'''
id_irs_start_x=5 # 镜子X方向的起始id（0~xxx）5
id_irs_end_x=15 # 镜子X方向的结束id（0~xxx）15
id_irs_start_y = 5 # 镜子Y方向的起始id（0~xxx）5
id_irs_end_y = 15 # 镜子Y方向的结束id（0~xxx）15

x_irs_min= id_irs_start_x*stepX # 镜子的起始X坐标
x_irs_max= id_irs_end_x*stepX # 镜子的结束X坐标
y_irs_min= id_irs_start_y*stepY # 镜子的起始Y坐标
y_irs_max= id_irs_end_y*stepY # 镜子的结束Y坐标
print(f"x_irs_min:{x_irs_min},x_irs_max:{x_irs_max},y_irs_min:{y_irs_min},y_irs_max:{y_irs_max}")

xs= np.arange(start=stepX/2,stop=lx,step=stepX) # 地面X方向的网格坐标
ys= np.arange(start=stepY/2,stop=ly,step=stepY) # 地面Y方向的网格坐标
zs= np.arange(start=stepZ/2,stop=lz,step=stepZ) # 墙面Z方向的网格坐标
x_grid, y_grid = np.meshgrid(xs, ys)  # XY平面的网格：地面
y_grid_wall, z_grid = np.meshgrid(ys, zs)  # YZ平面的网格:墙面;注意这里的y_grid_wall和y_grid是不同的,矩阵的维度不同，citation:https://blog.csdn.net/qq_46456049/article/details/112755442
# display(x_grid)
# display(y_grid)
x_grid


# # 定义随机 圆柱体的数量、位置
# * 固定数量，随机位置
# * 数量再随机位置

# In[97]:


np.random.seed(2) # 设置随机数种子,保证每次运行的随机数都是一样的
n=20 # 圆柱体的数量,10,20,30,40,50,...
edge_pad=0.5 # 圆柱体的边缘间距
x_barrs,y_barrs = np.random.uniform(0+edge_pad, lx-edge_pad, n),np.random.uniform(0+edge_pad, ly-edge_pad, n) #随机分布
x_barrs,y_barrs
# plot them, each point is a circle with radius of cylinder_r
plt.scatter(x_barrs,y_barrs,c='r',s=100)
# plt.show()


# # 计算GLOS

# In[98]:


def GLOSwithoutShadow(xAP,yAP,zAP=lz):
    '''
    无遮挡时整个房间地面的GLOS（全部地面网格），它后面应该和地面网格是否遮挡的0/1矩阵相乘，得到包含遮挡的GLOS
    计算灯坐标和的地面网格的距离，然后计算GLOS
    :param xAP: 灯的X坐标
    :param yAP: 灯的Y坐标
    :param zAP: 灯的Z坐标
    '''
    D1=np.sqrt((x_grid-xAP)**2+(y_grid-yAP)**2+(z_grid-(zAP-h))**2) # 灯到地面网格点的距离，是一个Nx*Ny的矩阵
    cosphi_A1 = zAP / D1  # angle vector
    Glos_without_shadow = (m + 1) * Adet * cosphi_A1**(m + 1) / (2 * np.pi * D1**2)  # GLOS
    return Glos_without_shadow

def GLOSwithShadow(Glos_without_shadow,Mask):
    '''
    包含遮挡的GLOS
    :param Glos_without_shadow: 不含遮挡的GLOS
    :param Mask: 地面遮挡的 掩模(mask)矩阵，是具有Nx*Ny维度的布尔类型矩阵
    :return:
    '''
    # channel DC gain for source 1
    P_rec = P_total * (Glos_without_shadow * Mask) * Ts * G_Con  # received power from source 1
    return P_rec

def calMaskwithCylinder(cylinder_x,cylinder_y,cylinder_h,cylinder_r,xAP,yAP,zAP=lz,is_debug=False):
    '''
    计算有圆柱体遮挡情况下的掩模矩阵:
    【算法原理】计算网格中心点，与灯的坐标点形成的直线是否与圆柱体相交，如果相交，则该网格被遮挡
    :param cylinder_x: 圆柱体底面圆心的X坐标
    :param cylinder_y: 圆柱体底面圆心的Y坐标
    :param cylinder_h: 圆柱体的高度
    :param cylinder_r: 圆柱体的半径
    :param xAP: 灯的X坐标
    :param yAP: 灯的Y坐标
    :param zAP: 灯的Z坐标
    :return:
    '''
    Mask=np.ones_like(x_grid) # 先初始化为1，表示没有遮挡
    for i in range(Nx):
        for j in range(Ny):
            cylinder_bottom_center=np.array([cylinder_x,cylinder_y,0])
            cylinder_vector=np.array([0,0,cylinder_h])
            cylinder_radius=cylinder_r
            cylinder=Cylinder(point=cylinder_bottom_center,vector=cylinder_vector,radius=cylinder_radius) # 圆柱体
            line=Line([x_grid[i,j],y_grid[i,j],h],[xAP,yAP,zAP]) # 地面网格中心点到灯的直线
            try:
                point_a,point_b=cylinder.intersect_line(line,infinite=False) # 计算直线与圆柱体的交点
                print(f"--- 底面网格：i:{i},j:{j},坐标：",[x_grid[i,j],y_grid[i,j],h],'---') if is_debug else None
                print(f'圆柱：cylder_bottom_center:{cylinder_bottom_center},cylinder_vector:{cylinder_vector},cylinder_radius:{cylinder_radius}') if is_debug else None
                print(f'交点：point_a:{point_a},point_b:{point_b}') if is_debug else None
                # plot_3d(
                #     line.plotter(c='k'),
                #     cylinder.plotter(alpha=0.2),
                #     point_a.plotter(c='r', s=100),
                #     point_b.plotter(c='r', s=100),
                # )
                Mask[i,j]=0
            except:
                pass
    return Mask

# save the mask to output folder as csv file
# np.savetxt('output/mask_1.5_1.5_3.csv',mask,delimiter=',')
Glos_without_shadow__=GLOSwithoutShadow(2.5,2.5,lz)
mask__=calMaskwithCylinder(cylinder_x,cylinder_y,cylinder_h,cylinder_r,2.5,0.5,lz)
GLOS=GLOSwithShadow(Glos_without_shadow__,mask__)
GLOS


# # 测试：阴影点

# In[99]:


from skspatial.objects import Line, Cylinder
from skspatial.plotting import plot_3d

cylinder = Cylinder([2.5,2.5, 0], [0, 0, 1.65], 0.15)
line = Line([2.625, 2.8, 0.75], [2.5,2.5,3.0])

point_a, point_b = cylinder.intersect_line(line, infinite=False)
print(f'point_a:{point_a},point_b:{point_b}')


# # 计算镜面墙的GNLOS

# In[100]:


def calGNLOS(omega,gamma,xAP,yAP,zAP=lz,is_debug=False):
    '''
    计算GNLOS矩阵
    :param omega: 镜子的角度1
    :param gamma: 镜子的角度2
    :param AP_vec: 灯的坐标向量
    :return:
    '''
    AP_vec=np.array([xAP,yAP,zAP]) # 灯的坐标向量
    H_sum=np.zeros((Nx,Ny)) # 初始化总地面矩阵
    for j in range(Ny): # 遍历墙面网格的Y坐标
        for k in range(Nz): # 遍历墙面网格的Z坐标
            '''在某一个灯、墙面点情况下，计算地面矩阵的接受到的反射光'''
            H=np.zeros((Nx,Ny)) # 初始化地面矩阵
            xIRS,yIRS,zIRS=0,ys[j],zs[k] # 镜子格点的坐标X,Y,Z=const
            IRS_vec=np.array([xIRS,yIRS,zIRS]) # 镜子格点的坐标向量
            print(f"IRS_vec:{IRS_vec}") if is_debug else None

            '''计算公式（x==0的墙）→ x=xa的墙，y==0的墙'''
            D1_A1 = np.linalg.norm(AP_vec - IRS_vec) # distance from LED to WP1 # 灯到镜子的距离值，标量
            cos_phi = np.abs(zIRS-lz)/D1_A1 # angle of incidence to reflection point # 角度，标量
            cos_alpha = np.abs(xAP-xIRS)/D1_A1 # angle of incidence to reflection point # 角度，标量xAP-xIRS → d_IRS_to_concerned_wall
            print(f"D1_A1:{D1_A1},cos_phi:{cos_phi},cos_alpha:{cos_alpha}") if is_debug else None

            D2_A1=np.sqrt((x_grid-xIRS)**2+(y_grid-yIRS)**2+(h-zIRS)**2) # 【矩阵】墙/镜子到地面网格点的距离，是一个Nx*Ny的矩阵
            cos_beta = np.abs(xIRS-x_grid)/D2_A1 # 矩阵
            cos_psi = np.abs(zIRS-h)/D2_A1 # 标量/矩阵→矩阵：是一个Nx*Ny的矩阵

            '''判断前墙面网格点是否属于墙面'''
            #is_belongs_to_wall=((xIRS<x_irs_min) | (xIRS>x_irs_max) | (yIRS<y_irs_min) | (yIRS>y_irs_max)) # 当前墙面网格点是否属于墙面
            is_belongs_to_wall=((yIRS<x_irs_min) | (yIRS>x_irs_max) | (zIRS<y_irs_min) | (zIRS>y_irs_max))
            if is_belongs_to_wall: # 如果属于墙面
                ids_wall=(np.abs(np.arccos(cos_psi)) <= FOV_radian) # 把≤FOV的id号取出
                if np.count_nonzero(ids_wall)>0:
                    print(f"count_wall:{np.count_nonzero(ids_wall)}") if is_debug else None
                    # 墙的计算公式
                    H[ids_wall] = (m + 1) * Adet * rho_wall * dA * (cos_phi ** m) * cos_alpha * cos_beta[ids_wall] * cos_psi[ids_wall] / (2 * (np.pi ** 2) * (D1_A1 ** 2) * D2_A1[ids_wall] ** 2)

                    print(f"H[ids_wall]:{H[ids_wall]}") if is_debug else None
            else: # 如果属于镜子
                ids_irs=(np.abs(np.arccos(cos_psi)) <= FOV_radian) # 把≤FOV的id号取出
                if np.count_nonzero(ids_irs)>0:
                    print(f"count_irs):{np.count_nonzero(ids_irs)}") if is_debug else None
                    print(f"omega:{omega},gamma:{gamma}") if is_debug else None
                    d_AP_IRS_for_alpha=D1_A1 # 灯到镜子的距离
                    d_IRS_PD_for_beta=D2_A1 # 墙到地面格点的距离

                    cos_alpha=np.abs((xIRS-xAP)*cos(omega)*sin(gamma)/d_AP_IRS_for_alpha+(yIRS-yAP)*cos(omega)*cos(gamma)/d_AP_IRS_for_alpha+(zIRS-lz)*sin(omega)/d_AP_IRS_for_alpha) # 灯到墙的某个值，是一个标量

                    cos_beta=np.abs((x_grid-xIRS)*cos(omega)*sin(gamma)/d_IRS_PD_for_beta+(y_grid-yIRS)*cos(omega)*cos(gamma)/d_IRS_PD_for_beta+(h-zIRS)*sin(omega)/d_IRS_PD_for_beta) # 墙到地面的某种值，是一个Nx*Ny的矩阵

                    print(f'cos_alpha:{cos_alpha},cos_beta:{cos_beta}') if is_debug else None
                    H[ids_irs] = (m + 1) * Adet * rho_irs * dA * cos_phi ** m * cos_alpha * cos_beta[ids_irs] * cos_psi[ids_irs] / (2 * np.pi ** 2 * D1_A1 ** 2 * D2_A1[ids_irs] ** 2) # NLOS channel.
                    print(f"H[ids_irs]:{H[ids_irs]}") if is_debug else None

            print(f"H:{H}") if is_debug else None
            H_sum=H_sum+H
            print(f'H_sum:{H_sum}') if is_debug else None
    return H_sum * P_total * Ts * G_Con # P_total,Ts,G_con 都是前面计算好的定值


# # 计算其他3面墙的GNLOS

# In[101]:


def calGNLOSOthers(xAP,yAP,zAP=lz,wall_position='Xmax',is_debug=False):
    '''
    计算除X=0外的其他3面墙的GNLOS矩阵
    :param xAP: 灯的x坐标
    :param yAP: 灯的y坐标
    :param zAP: 灯的z坐标
    :param wall_position: 墙的位置，’Xmax‘,’Ymax‘,’Ymin‘
    :param is_debug: 是否打印调试信息
    :return:
    '''
    AP_vec=np.array([xAP,yAP,zAP]) # 灯的坐标向量
    H_sum=np.zeros((Nx,Ny)) # 初始化总地面矩阵

    nj,nk=0,0 # 初始化墙面网格点数量
    if wall_position=='Xmax': # 如果是Xmax墙
        nj,nk=Ny,Nz # 用于循环的变量
    else:# axis='Ymax' or Ymin:
        nj,nk=Nz,Ny

    for j in range(nj): # 遍历墙面网格的第1个维度
        for k in range(nk): # 遍历墙面网格的第2个维度
            '''在某一个灯、墙面点情况下，计算地面矩阵的接受到的反射光'''
            H=np.zeros((Nx,Ny)) # 初始化地面矩阵

            '''墙面网格点坐标'''
            xWall,yWall,zWall=0,0,0 # 初始化墙面网格点坐标
            if wall_position=='Xmax':
                xWall,yWall,zWall=lx,ys[j],zs[k] # 墙面格点的坐标X,Y,Z=const
            elif wall_position=='Ymin':
                xWall,yWall,zWall=xs[j],0,zs[k] # 墙面格点的坐标X,Y,Z=const
            else: # axis='Ymax':
                xWall,yWall,zWall=xs[j],ly,zs[k] # 墙面格点的坐标X,Y,Z=const
            Wall_vec=np.array([xWall,yWall,zWall]) # 墙面格点的坐标向量
            print(f"Wall_vec:{Wall_vec}") if is_debug else None

            '''计算:灯到墙面的距离、墙面到地面的距离、灯到地面的距离'''
            D1_A1 = np.linalg.norm(AP_vec - Wall_vec) # distance from LED to WP1 # 灯到镜子的距离值，标量
            D_from_AP_to_Wall,D_from_Wall_to_Ground=None,None # 初始化灯到墙的距离和墙到地面的距离
            if wall_position=='Xmax':
                D_from_AP_to_Wall=np.abs(xWall-xAP) # 灯 到 墙面格点的距离值，标量
                D_from_Wall_to_Ground=np.abs(x_grid-xWall) # 墙面格点 到 地面格点的距离值，矩阵
            else: # axis='Ymax' or Ymin:
                D_from_AP_to_Wall=np.abs(yWall-yAP) # 灯 到 墙面格点的距离值，标量
                D_from_Wall_to_Ground=np.abs(y_grid-yWall) # 墙面格点 到 地面格点的距离值，矩阵

            '''计算各种角度的三角函数值'''
            cos_phi = np.abs(zWall-lz)/D1_A1 # angle of incidence to reflection point # 角度，标量
            cos_alpha = D_from_AP_to_Wall/D1_A1 # angle of incidence to reflection point # 角度，标量xAP-xWall → d_Wall_to_concerned_wall
            print(f"D1_A1:{D1_A1},cos_phi:{cos_phi},cos_alpha:{cos_alpha}") if is_debug else None

            D2_A1=np.sqrt((x_grid-xWall)**2+(y_grid-yWall)**2+(h-zWall)**2) # 【矩阵】墙/镜子到地面网格点的距离，是一个Nx*Ny的矩阵
            cos_beta = D_from_Wall_to_Ground/D2_A1 # 矩阵
            cos_psi = np.abs(zWall-h)/D2_A1 # 标量/矩阵→矩阵：是一个Nx*Ny的矩阵

            '''计算H矩阵'''
            ids_FOV=(np.abs(np.arccos(cos_psi)) <= FOV_radian) # 把≤FOV的id号取出
            if np.count_nonzero(ids_FOV)>0:
                print(f"count_wall:{np.count_nonzero(ids_FOV)}") if is_debug else None
                # 墙的计算公式
                H[ids_FOV] = (m + 1) * Adet * rho_wall * dA * (cos_phi ** m) * cos_alpha * cos_beta[ids_FOV] * cos_psi[ids_FOV] / (2 * (np.pi ** 2) * (D1_A1 ** 2) * D2_A1[ids_FOV] ** 2)

                print(f"H[ids_FOV]:{H[ids_FOV]}") if is_debug else None

            print(f"H:{H}") if is_debug else None
            H_sum=H_sum+H
            print(f'H_sum:{H_sum}') if is_debug else None
    return H_sum * P_total * Ts * G_Con # P_total,Ts,G_con 都是前面计算好的定值

#omega=np.radians(60) # 灯的角度！！！！！！！！！！记着后面要删除！！！！！！！！！！
#gamma=np.radians(45) # 灯的角度
# H_sum=calGNLOS(omega,gamma,xAP=2.5,yAP=2.5,zAP=lz,is_debug=1)


# # 测试：calGNLOS

# In[102]:


# xAP_temp,yAP_temp=0.5,0.5
xAP_temp,yAP_temp=2.5,2.5
omega=np.radians(60) # 灯的角度！！！！！！！！！！记着后面要删除！！！！！！！！！！
gamma=np.radians(45) # 灯的角度
GNLOSMatirx0=calGNLOS(omega,gamma,xAP=xAP_temp,yAP=yAP_temp,zAP=lz,is_debug=0)

#大佬说了，不影响，356～359都注释掉也行

# 生成横纵坐标的网格点
xmesh, ymesh = np.meshgrid(xs, ys)
# 将网格点坐标转换成一维数组，并将GNLOSMatirx展平作为Z坐标
xr = xmesh.ravel()
yr = ymesh.ravel()
zr0= GNLOSMatirx0.ravel()
print(f"xr.shape:{xr.shape},yr.shape:{yr.shape},zr.shape:{zr0.shape}")
# 画3D散点图
# fig = px.scatter_3d(x=xr, y=yr, z=zr0, color=zr0, opacity=0.5)
# fig.show()


# In[103]:


GNLOSMatirx1=calGNLOSOthers(xAP=xAP_temp,yAP=yAP_temp,zAP=lz,wall_position='Xmax',is_debug=False)
# plot the GNLOSMatirx in 3D using plotly.express

# 生成横纵坐标的网格点
xmesh, ymesh = np.meshgrid(xs, ys)
# 将网格点坐标转换成一维数组，并将GNLOSMatirx展平作为Z坐标
xr = xmesh.ravel()
yr = ymesh.ravel()
zr1= GNLOSMatirx1.ravel()
print(f"xr.shape:{xr.shape},yr.shape:{yr.shape},zr.shape:{zr1.shape}")
# 画3D散点图
# fig = px.scatter_3d(x=xr, y=yr, z=zr1, color=zr1, opacity=0.5)
# fig.show()


# In[104]:


GNLOSMatirx2=calGNLOSOthers(xAP=xAP_temp,yAP=yAP_temp,zAP=lz,wall_position='Ymin',is_debug=False)
zr2 = GNLOSMatirx2.ravel()
# fig = px.scatter_3d(x=xr, y=yr, z=zr2, color=zr2, opacity=0.5)
# fig.show()


# In[105]:


GNLOSMatirx3=calGNLOSOthers(xAP=xAP_temp,yAP=yAP_temp,zAP=lz,wall_position='Ymax',is_debug=False)
zr3 = GNLOSMatirx3.ravel()
# fig = px.scatter_3d(x=xr, y=yr, z=zr3, color=zr3, opacity=0.5)
# fig.show()


# In[106]:


GNLOSMatirx_all=GNLOSMatirx0+GNLOSMatirx1+GNLOSMatirx2+GNLOSMatirx3
zr_all = GNLOSMatirx_all.ravel()
# fig = px.scatter_3d(x=xr, y=yr, z=zr_all, color=zr_all, opacity=0.5)
# fig.show()


# # 定义边界

# In[107]:


nLED=4
xl=np.zeros([2+2*nLED]) # 下边界：2个灯的角度，4对xy坐标：omega,gamma,xAP1,yAP1,xAP2,yAP2,xAP3,yAP3,xAP4,yAP4
xu=np.zeros([2+2*nLED]) # 上边界：2个灯的角度，4对xy坐标
xl[:2]=-np.pi/2
xu[:2]=np.pi/2
for i in range(2,2+2*nLED,2):
    xu[i]=lx
    xu[i+1]=ly
print(f'xl:{xl},\n xu:{xu},len(xl):{len(xl)}')


# In[108]:


# 定义XY平面内随机个数的和随机坐标


# # 定义模型
# * citation1:https://pymoo.org/getting_started/part_2.html
# * citation2: https://pymoo.org/problems/elementwise.html

# In[109]:


import numpy as np
from pymoo.core.problem import ElementwiseProblem

class LightProblem(ElementwiseProblem):
    def __init__(self,x_barrs,y_barrs):
        super().__init__(n_var=len(xl), # 决策变量的个数
                         n_obj=2, # 目标函数的个数
                         n_ieq_constr=0, # 非等式约束的个数
                         xl=xl, # 决策变量的下边界
                         xu=xu, # 决策变量的上边界
                         )

    def _evaluate(self, x, out, *args, **kwargs):
        # print(f"x_barrs:{x_barrs},y_barrs:{y_barrs}") #if is_debug else None
        omega,gamma,xAP1,yAP1,xAP2,yAP2,xAP3,yAP3,xAP4,yAP4=x # 解码
        start_time=time.time()
        print(f"omega:{omega},gamma:{gamma},xAP1:{xAP1},yAP1:{yAP1},xAP2:{xAP2},yAP2:{yAP2},xAP3:{xAP3},yAP3:{yAP3},xAP4:{xAP4},yAP4:{yAP4}")

        xAPs, yAPs = [xAP1, xAP2, xAP3, xAP4], [yAP1, yAP2, yAP3, yAP4]

        GLOS,GNLOS=np.zeros((Nx,Ny)),np.zeros((Nx,Ny))
        for xAP,yAP in zip(xAPs,yAPs): # 循环灯
            # print(f'xAP:{xAP},yAP:{yAP}')
            '''逐个灯地计算GLOS'''
            mask_temp_onelight_allbarrs = np.ones((Nx, Ny))
            for cylinder_x,cylinder_y in zip(x_barrs,y_barrs): # 循环柱子/障碍物
                mask_temp=calMaskwithCylinder(cylinder_x,cylinder_y,cylinder_h,cylinder_r,xAP,yAP,lz)
                mask_temp_onelight_allbarrs=mask_temp_onelight_allbarrs*mask_temp # 布尔变量的逻辑“与”等效于：0,1变量的乘法

            Glos_without_shadow_temp=GLOSwithoutShadow(xAP,yAP,lz)
            GLOS_temp=GLOSwithShadow(Glos_without_shadow_temp,mask_temp_onelight_allbarrs)
            GLOS=GLOS+GLOS_temp # 逻辑和等效于加，完成了多人多灯

            '''逐个灯地计算GNLOS'''
            GNLOS_temp=calGNLOS(omega,gamma,xAP,yAP,zAP=lz,is_debug=False)
            GNLOS_Xmax=calGNLOSOthers(xAP,yAP,zAP=lz,wall_position='Xmax',is_debug=False)
            GNLOS_Ymin=calGNLOSOthers(xAP,yAP,zAP=lz,wall_position='Ymin',is_debug=False)
            GNLOS_Ymax=calGNLOSOthers(xAP,yAP,zAP=lz,wall_position='Ymax',is_debug=False)
            GNLOS=GNLOS+GNLOS_temp+GNLOS_Xmax+GNLOS_Ymin+GNLOS_Ymax

        G=Pt*(GLOS+GNLOS)
        G_mean=np.mean(G)

        f1=B*np.log2(1+np.exp(1)*(((p/q)*R_pd*(np.sum(GNLOS)+np.sum(GLOS)))**2)/(2*np.pi*N*B)) #好像少了一个R_pd，2.17改 原本少了一个平方,2.18加的**2
        #原本代码：f1=B*np.log2(1+np.exp(1)*((p/q)*R_pd*(np.sum(GNLOS)+np.sum(GLOS))/2*np.pi*N*B)  #(2*np.pi*N*B))
        f1=-f1 # 最大化问题转化为最小化问题
        f2 = np.sqrt(np.mean((G-G_mean)**2)) # RMSE最小化
        elapsed_time=time.time()-start_time
        print(f'f1:{f1},f2:{f2},elapsed_time:{elapsed_time}')

        out["F"] = [f1, f2]



# # 单次：定义算法并求解
# * citataion: https://pymoo.org/algorithms/moo/nsga2.html#nb-nsga2

# In[110]:

'''需要定义的变量'''
pop_size=40
n_gen=20

algorithm = NSGA2(
    pop_size=pop_size,  # 种群大小:40,50,100,1000
    # n_offsprings=5,
    sampling=FloatRandomSampling(),
    crossover=SBX(prob=0.9, eta=15),
    mutation=PM(eta=20),
    eliminate_duplicates=True
)
termination = get_termination("n_gen", n_gen)  # 迭代次数:10,20,50,100,...
if __name__ == '__main__':
    seed_start=2 # 随机种子,在不同文件中运行该文件时可修改这个值
    for n_barrs in [20]:  # 障碍物数量【5,10,20,....】,可以写多个[5,10]
        n_run=1 # 每个障碍物数量下，重复求解的次数
        for i_run in range(n_run):  # 每个障碍物数量下，重复10,100,1000...次
            seed_start+=1

            output_dir = f'output_multi/POP{pop_size}_GEN{n_gen}_Barrs{n_barrs}_Run{n_run}@{i_run+1}_Seed{seed_start}'
            if not os.path.exists(output_dir):
                os.makedirs(output_dir)

            np.random.seed(seed_start)
            edge_pad = 0.5
            x_barrs, y_barrs = np.random.uniform(0 + edge_pad, lx - edge_pad, n_barrs), np.random.uniform(0 + edge_pad,ly - edge_pad,n_barrs)
            df_barrs = pd.DataFrame({'x': x_barrs, 'y': y_barrs})
            # to excel
            df_barrs.to_excel(f'{output_dir}/barrs.xlsx', index=False)

            problem = LightProblem(x_barrs=x_barrs, y_barrs=y_barrs) # 求解问题的实例化

            res = minimize(problem,
                           algorithm,
                           termination,
                           seed=1,
                           save_history=True,
                           verbose=True)

            X = res.X
            F = res.F


            # # 单次：导出求解结果

            # In[ ]:


            print(f'X:{X},\n F:{F}')
            df_x=pd.DataFrame(X,columns=["omega","gamma","xAP1","yAP1","xAP2","yAP2","xAP3","yAP3","xAP4","yAP4"])
            df_x_copy=df_x.copy()
            # transform the omega and gamma to degree
            df_x_copy['omega']=df_x_copy['omega']*180/np.pi
            df_x_copy['gamma']=df_x_copy['gamma']*180/np.pi

            df_f=pd.DataFrame(F,columns=["f1","f2"])
            # to excel
            df_x.to_excel(f'{output_dir}/x.xlsx')
            df_x_copy.to_excel(f'{output_dir}/x_deg.xlsx')
            df_f.to_excel(f'{output_dir}/f.xlsx')


            # # 单次：导出GLOS和GNLOS

            # In[ ]:
            for ii in range(len(X)):
                x=X[ii]
                omega,gamma,xAP1,yAP1,xAP2,yAP2,xAP3,yAP3,xAP4,yAP4=x # 解码
                start_time=time.time()
                print(f"----{ii}----omega:{omega},gamma:{gamma},xAP1:{xAP1},yAP1:{yAP1},xAP2:{xAP2},yAP2:{yAP2},xAP3:{xAP3},yAP3:{yAP3},xAP4:{xAP4},yAP4:{yAP4}")

                xAPs, yAPs = [xAP1, xAP2, xAP3, xAP4], [yAP1, yAP2, yAP3, yAP4]

                GLOS,GNLOS=np.zeros((Nx,Ny)),np.zeros((Nx,Ny))
                for xAP,yAP in zip(xAPs,yAPs):
                    # print(f'xAP:{xAP},yAP:{yAP}')
                    mask_temp=calMaskwithCylinder(cylinder_x,cylinder_y,cylinder_h,cylinder_r,xAP,yAP,lz)
                    Glos_without_shadow_temp=GLOSwithoutShadow(xAP,yAP,lz)
                    GLOS_temp=GLOSwithShadow(Glos_without_shadow_temp,mask_temp)
                    GLOS=GLOS+GLOS_temp

                    GNLOS_temp=calGNLOS(omega,gamma,xAP,yAP,zAP=lz,is_debug=False)
                    GNLOS=GNLOS+GNLOS_temp

                G=Pt*(GLOS+GNLOS)
                # save the GLOS and GNLOS and G to excel
                df_GLOS=pd.DataFrame(GLOS)
                df_GNLOS=pd.DataFrame(GNLOS)
                df_G=pd.DataFrame(G)
                df_GLOS.to_excel(f'{output_dir}/GLOS_{ii}.xlsx')
                df_GNLOS.to_excel(f'{output_dir}/GNLOS_{ii}.xlsx')
                df_G.to_excel(f'{output_dir}/G_{ii}.xlsx')


            # # 可视化

            # In[ ]:


            import matplotlib.pyplot as plt
            xl, xu = problem.bounds()
            plt.figure(figsize=(7, 5))
            plt.scatter(X[:, 0], X[:, 1], s=30, facecolors='none', edgecolors='r')
            plt.xlim(xl[0], xu[0])
            plt.ylim(xl[1], xu[1])
            plt.xlabel("$\omega$")
            plt.ylabel("$\gamma$")
            plt.title("Design Space (omega,gamma)")
            # save the figure
            plt.savefig(f'{output_dir}/design_space.png')
            # plt.show()

            plt.figure(figsize=(7, 5))
            plt.scatter(F[:, 0], F[:, 1], s=30, facecolors='none', edgecolors='blue')
            plt.xlabel('f1')
            plt.ylabel('f2')
            plt.title("Objective Space (Pareto Front)")
            # save the figure
            plt.savefig(f'{output_dir}/objective_space.png')




